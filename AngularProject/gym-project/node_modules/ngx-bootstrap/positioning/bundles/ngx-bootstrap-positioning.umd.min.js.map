{"version":3,"sources":["ng://ngx-bootstrap/positioning/ng-positioning.ts","ng://ngx-bootstrap/positioning/positioning.service.ts"],"names":["Positioning","prototype","position","element","round","elPosition","parentOffset","width","height","top","bottom","left","right","this","getStyle","bcRect","getBoundingClientRect","offsetParentEl","offsetParent","offset","document","documentElement","clientTop","clientLeft","Math","elBcr","viewportOffset","window","pageYOffset","pageXOffset","elOffset","offsetHeight","offsetWidth","positionElements","hostElement","targetElement","placement","appendToBody","hostElPosition","targetElStyles","getAllStyles","targetElBCR","placementPrimary","split","placementSecondary","targetElPosition","shiftHeight","center","shiftWidth","newPlacementPrimary","autoPosition","classList","add","parseFloat","marginBottom","marginRight","preferredPosition","innerHeight","innerWidth","getComputedStyle","prop","isStaticPositioned","positionService","pos","style","PositioningService","options","target","attachment","_getHtmlElement","Injectable","querySelector","ElementRef","nativeElement"],"mappings":"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","sourcesContent":["/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\n\n// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\n// tslint:disable\nexport class Positioning {\n  public position(element: HTMLElement, round = true): ClientRect {\n    let elPosition: ClientRect;\n    let parentOffset: ClientRect = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    if (this.getStyle(element, 'position') === 'fixed') {\n      const bcRect = element.getBoundingClientRect();\n      elPosition = {\n        width: bcRect.width,\n        height: bcRect.height,\n        top: bcRect.top,\n        bottom: bcRect.bottom,\n        left: bcRect.left,\n        right: bcRect.right\n      };\n    } else {\n      const offsetParentEl = this.offsetParent(element);\n\n      elPosition = this.offset(element, false);\n\n      if (offsetParentEl !== document.documentElement) {\n        parentOffset = this.offset(offsetParentEl, false);\n      }\n\n      parentOffset.top += offsetParentEl.clientTop;\n      parentOffset.left += offsetParentEl.clientLeft;\n    }\n\n    elPosition.top -= parentOffset.top;\n    elPosition.bottom -= parentOffset.top;\n    elPosition.left -= parentOffset.left;\n    elPosition.right -= parentOffset.left;\n\n    if (round) {\n      elPosition.top = Math.round(elPosition.top);\n      elPosition.bottom = Math.round(elPosition.bottom);\n      elPosition.left = Math.round(elPosition.left);\n      elPosition.right = Math.round(elPosition.right);\n    }\n\n    return elPosition;\n  }\n\n  public offset(element: HTMLElement, round = true): ClientRect {\n    const elBcr = element.getBoundingClientRect();\n    const viewportOffset = {\n      top: window.pageYOffset - document.documentElement.clientTop,\n      left: window.pageXOffset - document.documentElement.clientLeft\n    };\n\n    let elOffset = {\n      height: elBcr.height || element.offsetHeight,\n      width: elBcr.width || element.offsetWidth,\n      top: elBcr.top + viewportOffset.top,\n      bottom: elBcr.bottom + viewportOffset.top,\n      left: elBcr.left + viewportOffset.left,\n      right: elBcr.right + viewportOffset.left\n    };\n\n    if (round) {\n      elOffset.height = Math.round(elOffset.height);\n      elOffset.width = Math.round(elOffset.width);\n      elOffset.top = Math.round(elOffset.top);\n      elOffset.bottom = Math.round(elOffset.bottom);\n      elOffset.left = Math.round(elOffset.left);\n      elOffset.right = Math.round(elOffset.right);\n    }\n\n    return elOffset;\n  }\n\n  public positionElements(\n    hostElement: HTMLElement,\n    targetElement: HTMLElement,\n    placement: string,\n    appendToBody?: boolean\n  ): ClientRect {\n    const hostElPosition = appendToBody\n      ? this.offset(hostElement, false)\n      : this.position(hostElement, false);\n    const targetElStyles = this.getAllStyles(targetElement);\n    const targetElBCR = targetElement.getBoundingClientRect();\n    let placementPrimary = placement.split(' ')[0] || 'top';\n    const placementSecondary = placement.split(' ')[1] || 'center';\n\n    let targetElPosition: ClientRect = {\n      height: targetElBCR.height || targetElement.offsetHeight,\n      width: targetElBCR.width || targetElement.offsetWidth,\n      top: 0,\n      bottom: targetElBCR.height || targetElement.offsetHeight,\n      left: 0,\n      right: targetElBCR.width || targetElement.offsetWidth\n    };\n\n    const shiftHeight: any = {\n      top: hostElPosition.top,\n      center:\n        hostElPosition.top +\n        hostElPosition.height / 2 -\n        targetElPosition.height / 2,\n      bottom: hostElPosition.top + hostElPosition.height\n    };\n    const shiftWidth: any = {\n      left: hostElPosition.left,\n      center:\n        hostElPosition.left +\n        hostElPosition.width / 2 -\n        targetElPosition.width / 2,\n      right: hostElPosition.left + hostElPosition.width\n    };    \n\n    if (placementPrimary === 'auto') {\n      let newPlacementPrimary = this.autoPosition(\n        targetElPosition,\n        hostElPosition,\n        targetElement,\n        placementSecondary\n      );\n      if (!newPlacementPrimary)\n        newPlacementPrimary = this.autoPosition(\n          targetElPosition,\n          hostElPosition,\n          targetElement\n        );\n      if (newPlacementPrimary) placementPrimary = newPlacementPrimary;\n      targetElement.classList.add(placementPrimary);\n    }\n\n    switch (placementPrimary) {\n      case 'top':\n        targetElPosition.top =\n          hostElPosition.top -\n          (targetElPosition.height +\n            parseFloat(targetElStyles.marginBottom));\n        targetElPosition.bottom +=\n          hostElPosition.top - targetElPosition.height;\n        targetElPosition.left = shiftWidth[placementSecondary];\n        targetElPosition.right += shiftWidth[placementSecondary];\n        break;\n      case 'bottom':\n        targetElPosition.top = shiftHeight[placementPrimary];\n        targetElPosition.bottom += shiftHeight[placementPrimary];\n        targetElPosition.left = shiftWidth[placementSecondary];\n        targetElPosition.right += shiftWidth[placementSecondary];\n        break;\n      case 'left':\n        targetElPosition.top = shiftHeight[placementSecondary];\n        targetElPosition.bottom += shiftHeight[placementSecondary];\n        targetElPosition.left =\n          hostElPosition.left -\n          (targetElPosition.width + parseFloat(targetElStyles.marginRight));\n        targetElPosition.right +=\n          hostElPosition.left - targetElPosition.width;\n        break;\n      case 'right':\n        targetElPosition.top = shiftHeight[placementSecondary];\n        targetElPosition.bottom += shiftHeight[placementSecondary];\n        targetElPosition.left = shiftWidth[placementPrimary];\n        targetElPosition.right += shiftWidth[placementPrimary];\n        break;\n    }\n\n    targetElPosition.top = Math.round(targetElPosition.top);\n    targetElPosition.bottom = Math.round(targetElPosition.bottom);\n    targetElPosition.left = Math.round(targetElPosition.left);\n    targetElPosition.right = Math.round(targetElPosition.right);\n\n    return targetElPosition;\n  }\n\n  private autoPosition(\n    targetElPosition: ClientRect,\n    hostElPosition: ClientRect,\n    targetElement: HTMLElement,\n    preferredPosition?: string\n  ) {\n    if (\n      (!preferredPosition || preferredPosition === 'right') &&\n      targetElPosition.left + hostElPosition.left - targetElPosition.width <\n        0\n    ) {\n      return 'right';\n    } else if (\n      (!preferredPosition || preferredPosition === 'top') &&\n      targetElPosition.bottom +\n        hostElPosition.bottom +\n        targetElPosition.height >\n        window.innerHeight\n    ) {\n      return 'top';\n    } else if (\n      (!preferredPosition || preferredPosition === 'bottom') &&\n      targetElPosition.top + hostElPosition.top - targetElPosition.height < 0\n    ) {\n      return 'bottom';\n    } else if (\n      (!preferredPosition || preferredPosition === 'left') &&\n      targetElPosition.right +\n        hostElPosition.right +\n        targetElPosition.width >\n        window.innerWidth\n    ) {\n      return 'left';\n    }\n    return null;\n  }\n\n  private getAllStyles(element: HTMLElement) {\n    return window.getComputedStyle(element);\n  }\n\n  private getStyle(element: HTMLElement, prop: string): string {\n    return (this.getAllStyles(element) as any)[prop];\n  }\n\n  private isStaticPositioned(element: HTMLElement): boolean {\n    return (this.getStyle(element, 'position') || 'static') === 'static';\n  }\n\n  private offsetParent(element: HTMLElement): HTMLElement {\n    let offsetParentEl =\n      <HTMLElement>element.offsetParent || document.documentElement;\n\n    while (\n      offsetParentEl &&\n      offsetParentEl !== document.documentElement &&\n      this.isStaticPositioned(offsetParentEl)\n    ) {\n      offsetParentEl = <HTMLElement>offsetParentEl.offsetParent;\n    }\n\n    return offsetParentEl || document.documentElement;\n  }\n}\n\nconst positionService = new Positioning();\n\nexport function positionElements(\n  hostElement: HTMLElement,\n  targetElement: HTMLElement,\n  placement: string,\n  appendToBody?: boolean\n): void {\n  const pos = positionService.positionElements(\n    hostElement,\n    targetElement,\n    placement,\n    appendToBody\n  );\n\n  targetElement.style.top = `${pos.top}px`;\n  targetElement.style.left = `${pos.left}px`;\n}\n","import { Injectable, ElementRef } from '@angular/core';\nimport { positionElements } from './ng-positioning';\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n@Injectable()\nexport class PositioningService {\n  position(options: PositioningOptions): void {\n    const {element, target, attachment, appendToBody} = options;\n    positionElements(\n      _getHtmlElement(target),\n      _getHtmlElement(element),\n      attachment,\n      appendToBody\n    );\n  }\n\n}\n\nfunction _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n"]}